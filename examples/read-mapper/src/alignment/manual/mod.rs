use std::path::PathBuf;

use super::{
    arg_parser::check_input_file_extension_is_allowed,
    query_reader::QueryReader,
    write_results::{
        extend_sam_line_with_itoa_buffer, extend_tsv_line_with_itoa_buffer, write_sam_header,
        write_tsv_header,
    },
};
use crate::{error, error_msg, reference::ReferencePathDetector, Result};
use clap::{arg, value_parser, Arg, ArgMatches, Command};
use sigalign::{
    algorithms::{
        Algorithm, Local, LocalWithChunk, LocalWithLimit, SemiGlobal, SemiGlobalWithChunk,
        SemiGlobalWithLimit,
    },
    Aligner, Reference,
};

mod thread_pool;
use thread_pool::ThreadPool;

const THREAD_BATCH_SIZE: usize = 64;

pub struct ManualAlignmentApp;

#[derive(Debug, Clone)]
struct Config {
    // Input
    input_file: PathBuf,
    is_gzip_compressed: bool,
    is_fasta_file: bool, // true: FASTA, false: FASTQ
    reference_path_detector: ReferencePathDetector,
    // Alignment Regulator
    px: u32,
    po: u32,
    pe: u32,
    minl: u32,
    maxp: f32,
    // Algorithm
    is_local: bool,
    limit: Option<u32>,
    chunk: Option<(u32, u32)>,
    // Others
    with_reverse_complementary: bool,
    num_threads: usize,
    output_is_sam: bool, // true: SAM, false: TSV
}

impl ManualAlignmentApp {
    pub fn tag() -> &'static str {
        "manual"
    }
    pub fn get_command() -> Command {
        Command::new(Self::tag())
            .about("Align reads to reference with manually defined parameters")
            .arg_required_else_help(true)
            .arg(arg!(-i --input <FILE> "Input query FASTA or FASTQ file path (can be gzipped)")
                .value_parser(value_parser!(PathBuf))
                .required(true)
                .display_order(1))
            .arg(arg!(-r --reference <FILE> "SigAlign reference file generated by 'reference' subcommand")
                .value_parser(value_parser!(PathBuf))
                .required(true)
                .display_order(2))
            .arg(Arg::new("penalties").short('p').long("penalties")
                .value_names(["INT", "INT", "INT"])
                .num_args(3)
                .help("Mismatch, Gap-open and Gap-extend penalties")
                .required(true)
                .display_order(3))
            .arg(Arg::new("cutoffs").short('c').long("cutoffs")
                .value_names(["INT", "FLOAT"])
                .num_args(2)
                .help("Minimum length and Maximum penalty per length")
                .required(true)
                .display_order(4))
            .arg(Arg::new("limit").short('l').long("limit")
                .help("Limit the number of alignments for each query")
                .value_parser(value_parser!(u32))
                .conflicts_with("chunk")
                .required(false)
                .display_order(5))
            .arg(Arg::new("chunk").short('u').long("chunk")
                .help("Perform chunked alignment with (chunk size, sliding size)")
                .value_names(["INT", "INT"])
                .value_parser(value_parser!(u32))
                .required(false)
                .display_order(6))
            .arg(Arg::new("thread").short('t').long("thread")
                .help("The number of threads")
                .default_value("4")
                .value_parser(value_parser!(u32))
                .required(false)
                .display_order(7))
            .arg(arg!(-f --forward "Use forward strand only")
                .display_order(8)
                .required(false))
            .arg(arg!(--semi_global "Use semi-global alignment instead of local")
                .display_order(9)
                .required(false))
            .arg(arg!(--sam "Output format is SAM instead of TSV")
                .display_order(10)
                .required(false))
    }
    pub fn run(matches: &ArgMatches) -> Result<()> {
        // Parse arguments
        let config = Config::from_matches(matches)?;
        eprintln!("{:#?}", config);

        // Run by algorithm
        if config.is_local {
            if let Some(limit) = config.limit {
                let aligner = Aligner::new(LocalWithLimit::new(
                    config.px,
                    config.po,
                    config.pe,
                    config.minl,
                    config.maxp,
                    limit,
                )?);
                Self::execute_alignment_with_thread_pool(&config, aligner)?;
            } else if let Some(chunk) = config.chunk {
                let aligner = Aligner::new(LocalWithChunk::new(
                    config.px,
                    config.po,
                    config.pe,
                    config.minl,
                    config.maxp,
                    chunk.0,
                    chunk.1,
                )?);
                Self::execute_alignment_with_thread_pool(&config, aligner)?;
            } else {
                let aligner = Aligner::new(Local::new(
                    config.px,
                    config.po,
                    config.pe,
                    config.minl,
                    config.maxp,
                )?);
                Self::execute_alignment_with_thread_pool(&config, aligner)?;
            }
        } else {
            if let Some(limit) = config.limit {
                let aligner = Aligner::new(SemiGlobalWithLimit::new(
                    config.px,
                    config.po,
                    config.pe,
                    config.minl,
                    config.maxp,
                    limit,
                )?);
                Self::execute_alignment_with_thread_pool(&config, aligner)?;
            } else if let Some(chunk) = config.chunk {
                let aligner = Aligner::new(SemiGlobalWithChunk::new(
                    config.px,
                    config.po,
                    config.pe,
                    config.minl,
                    config.maxp,
                    chunk.0,
                    chunk.1,
                )?);
                Self::execute_alignment_with_thread_pool(&config, aligner)?;
            } else {
                let aligner = Aligner::new(SemiGlobal::new(
                    config.px,
                    config.po,
                    config.pe,
                    config.minl,
                    config.maxp,
                )?);
                Self::execute_alignment_with_thread_pool(&config, aligner)?;
            }
        };

        Ok(())
    }
    fn execute_alignment_with_thread_pool<A: Algorithm + 'static>(
        config: &Config,
        aligner: Aligner<A>,
    ) -> Result<()> {
        // Write header for results
        {
            let stdout = std::io::stdout().lock();
            if config.output_is_sam {
                write_sam_header(stdout, &config.reference_path_detector)?;
            } else {
                write_tsv_header(stdout)?;
            }
        }

        let thread_pool: ThreadPool = ThreadPool::new(
            config.num_threads,
            THREAD_BATCH_SIZE,
            aligner,
            config.with_reverse_complementary,
            config.output_is_sam,
        );

        let start_time = std::time::Instant::now();
        let reference_paths = config
            .reference_path_detector
            .load_reference_chunk_paths()?;
        let reference_chunk_count = reference_paths.len();
        for (reference_index, reference_path) in reference_paths.into_iter().enumerate() {
            eprintln!(
                "Processing reference chunk: {} / {}",
                reference_index + 1,
                reference_chunk_count
            );

            // Load reference
            let file = std::fs::File::open(reference_path)?;
            let reference = Reference::load_from(file)?;

            // Load query
            let query_reader = QueryReader::new(
                &config.input_file,
                config.is_gzip_compressed,
                config.is_fasta_file,
            )?;

            // Execute alignment
            thread_pool.execute(reference, query_reader);
        }
        drop(thread_pool);
        let elapsed_time = start_time.elapsed();
        eprintln!("Alignment finished in {:.2} s", elapsed_time.as_secs_f64());

        Ok(())
    }
}

impl Config {
    fn from_matches(matches: &ArgMatches) -> Result<Self> {
        // Input file paths
        let input_file = matches.get_one::<PathBuf>("input").unwrap().clone();
        let (is_gzip_compressed, is_fasta_file) =
            check_input_file_extension_is_allowed(&input_file)?;

        let reference_path = {
            let path = matches
                .get_one::<PathBuf>("reference")
                .ok_or(error!("Invalid reference fasta"))?
                .clone();
            // if !path.exists() {
            //     error_msg!("Reference file does not exist: {:?}", path);
            // } FIXME: Revive later
            ReferencePathDetector::new(&path)
        };

        // Alignment Regulator
        let (px, po, pe) = {
            let mut iterator: clap::parser::ValuesRef<_> =
                matches.get_many::<String>("penalties").unwrap();
            let px: u32 = iterator
                .next()
                .unwrap()
                .parse()
                .map_err(|_| error!("Mismatch penalty allows only positive integer"))?;
            let po: u32 = iterator
                .next()
                .unwrap()
                .parse()
                .map_err(|_| error!("Gap-open penalty allows only non-negative integer"))?;
            let pe: u32 = iterator
                .next()
                .unwrap()
                .parse()
                .map_err(|_| error!("Gap-extend penalty allows only positive integer"))?;
            (px, po, pe)
        };
        let (minl, maxp) = {
            let mut iterator: clap::parser::ValuesRef<_> =
                matches.get_many::<String>("cutoffs").unwrap();
            let minl: u32 = iterator
                .next()
                .unwrap()
                .parse()
                .map_err(|_| error!("Minimum length allows only positive integer"))?;
            let maxp: f32 = iterator
                .next()
                .unwrap()
                .parse()
                .map_err(|_| error!("Maximum penalty per length allows only positive float"))?;
            (minl, maxp)
        };

        // Algorithm
        let is_local = if matches.get_flag("semi_global") {
            false
        } else {
            true
        };
        let limit = matches.get_one::<u32>("limit").copied();
        let chunk = matches.get_one::<(u32, u32)>("chunk").copied();

        // Others
        let use_only_forward = matches.get_flag("forward");
        let num_threads = matches.get_one::<u32>("thread").copied().unwrap() as usize;
        let output_is_sam = matches.get_flag("sam");

        Ok(Self {
            input_file,
            is_gzip_compressed,
            is_fasta_file,
            reference_path_detector: reference_path,
            px,
            po,
            pe,
            minl,
            maxp,
            is_local,
            limit,
            chunk,
            with_reverse_complementary: !use_only_forward,
            num_threads,
            output_is_sam,
        })
    }
}
